<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>跟 etcd 学习数据库中事务隔离的实现 - 喵叔没话说</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="喵叔" />
  <meta name="description" content="众所周知，etcd 的数据模型是建立在 MVCC 基础上的（如果你不知，那一定是没看过我的这篇博客🙃）。在当前的实现中1，etcd 不仅提供了原子性的事务" />
<meta name="keywords" content="etcd, database, transaction, isolation level, mvcc, cas, 乐观锁, 数据库, 事务, 多版本并发控制, 并发" />







<meta name="generator" content="Hugo 0.110.0" />


<link rel="canonical" href="https://blog.betacat.io/post/2019/08/learn-transaction-isolation-levels-from-etcd/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.444f741ba7b684e63dff9a3b61ec1fb750c9b563b5a0b64153f1af8025c5fac1.css" integrity="sha256-RE90G6e2hOY9/5o7Yewft1DJtWO1oLZBU/GvgCXF&#43;sE=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="跟 etcd 学习数据库中事务隔离的实现" />
<meta property="og:description" content="众所周知，etcd 的数据模型是建立在 MVCC 基础上的（如果你不知，那一定是没看过我的这篇博客🙃）。在当前的实现中1，etcd 不仅提供了原子性的事务" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.betacat.io/post/2019/08/learn-transaction-isolation-levels-from-etcd/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-08-29T10:17:24+08:00" />
<meta property="article:modified_time" content="2020-01-03T22:56:24+08:00" />
<meta itemprop="name" content="跟 etcd 学习数据库中事务隔离的实现">
<meta itemprop="description" content="众所周知，etcd 的数据模型是建立在 MVCC 基础上的（如果你不知，那一定是没看过我的这篇博客🙃）。在当前的实现中1，etcd 不仅提供了原子性的事务"><meta itemprop="datePublished" content="2019-08-29T10:17:24+08:00" />
<meta itemprop="dateModified" content="2020-01-03T22:56:24+08:00" />
<meta itemprop="wordCount" content="5249">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="跟 etcd 学习数据库中事务隔离的实现"/>
<meta name="twitter:description" content="众所周知，etcd 的数据模型是建立在 MVCC 基础上的（如果你不知，那一定是没看过我的这篇博客🙃）。在当前的实现中1，etcd 不仅提供了原子性的事务"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-36049801-4', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script type="text/javascript">
    
    if (window != top) top.location.href = window.location.href
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9393129008813908"
     crossorigin="anonymous"></script>

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">喵叔没话说</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.betacat.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.betacat.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.betacat.io/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      喵叔没话说
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.betacat.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.betacat.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.betacat.io/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">跟 etcd 学习数据库中事务隔离的实现</h1>
      
      <div class="post-meta">
        <time datetime="2019-08-29" class="post-time">
          2019-08-29
        </time>
        
        <span class="more-meta"> 约 5249 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#预备知识">预备知识</a>
      <ul>
        <li><a href="#事务隔离级别">事务隔离级别</a></li>
        <li><a href="#etcd-中的版本">etcd 中的版本</a></li>
        <li><a href="#etcd-中的微事务">etcd 中的微事务</a></li>
      </ul>
    </li>
    <li><a href="#使用姿势">使用姿势</a></li>
    <li><a href="#内部实现">内部实现</a>
      <ul>
        <li><a href="#repeatablereads">RepeatableReads</a></li>
        <li><a href="#readcommitted">ReadCommitted</a></li>
        <li><a href="#serializable">Serializable</a></li>
        <li><a href="#serializablesnapshot">SerializableSnapshot</a></li>
        <li><a href="#区别汇总">区别汇总</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p>众所周知，etcd 的数据模型是建立在 MVCC 基础上的（如果你不知，那一定是没看过我的<a href="https://blog.betacat.io/post/mvcc-implementation-in-etcd/">这篇博客</a>🙃）。在当前的实现中<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>，etcd 不仅提供了原子性的事务操作，还对外暴露了实现这些原子操作的 MVCC 版本信息。要知道，在大部分使用了 MVCC 机制的数据库中，你很难找到底层 MVCC 的影子，因为上层的数据库都把它屏蔽掉了，用户只能使用数据库封装好的一些能力。而在 etcd 中，最底层的版本信息是公开的，这就给我们提供了很多种可能性。比如在官方的客户端 clientv3 中，有一个 <a href="https://github.com/etcd-io/etcd/tree/v3.3.10/clientv3/concurrency">concurrency</a> 包，这里面封装好的能力就足以覆盖 etcd 常见的几种使用场景：</p>
<ul>
<li><a href="https://github.com/etcd-io/etcd/blob/v3.3.10/clientv3/concurrency/mutex.go">mutex.go</a> 一个分布式锁的实现</li>
<li><a href="https://github.com/etcd-io/etcd/blob/v3.3.10/clientv3/concurrency/election.go">election.go</a> 一个分布式选举的实现，多用来实现 Active-Standby 的高可用模式</li>
<li><a href="https://github.com/etcd-io/etcd/blob/v3.3.10/clientv3/concurrency/stm.go">stm.go</a> 一个在<strong>客户端</strong>实现的事务框架，能将多条业务语句打包成一个原子操作</li>
</ul>
<p>其中的 stm (<a href="https://en.wikipedia.org/wiki/Software_transactional_memory">software transactional memory</a>) 实现的最有意思，它将原子性的事务实现得有模有样，还允许指定不同的隔离级别，就像在使用那些重量级的数据库一样。这让人不禁好奇，在拥有 MVCC 原语的基础上，它是怎样用 380 行代码实现出重量级的隔离效果的？</p>
<h2 id="预备知识">预备知识</h2>
<p>在进入代码细节之前，我们先要了解常见的几种隔离级别是什么，以及 etcd 暴露出来的版本信息有哪些？</p>
<h3 id="事务隔离级别">事务隔离级别</h3>
<p>数据库的几种<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB">事务隔离级别</a> （Transaction Isolation Levels）一直是面试的热点，几乎逢面必问（不要问我怎么知道的）。当然这种理论知识稍微理解一下也不难记住：</p>
<ul>
<li>未提交读（Read Uncommitted）：能够读取到其他事务中还未提交的数据，这可能会导致脏读的问题。</li>
<li>读已提交（Read Committed）：只能读取到已经提交的数据，即别的事务一提交，当前事务就能读取到被修改的数据，这可能导致不可重复读的问题。</li>
<li>可重复读（Repeated Read）：一个事务中，同一个读操作在事务的任意时刻都能得到同样的结果，其他事务的提交操作对本事务不会产生影响。</li>
<li>串行化（Serializable）：串行化的执行可能冲突的事务，即一个事务会阻塞其他事务。它通过牺牲并发能力来换取数据的安全，属于最高的隔离级别。</li>
</ul>
<h3 id="etcd-中的版本">etcd 中的版本</h3>
<p>MVCC 全称是多版本并发控制，它保留每一次的修改，并用版本号来追踪这些修改。所以相应的 etcd 里面也有很多版本的概念，我们先来理清楚它们之间的区别<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>：</p>
<ul>
<li><code>Revision</code>是一个全局的状态，每一次有更改操作（Put, Delete, Txn）时，Revision 的值都会增加。它的作用有点像一个逻辑时钟，全局递增不重复。我们可以通过 <a href="https://github.com/etcd-io/etcd/blob/v3.3.10/etcdserver/etcdserverpb/rpc.pb.go#L223">Response.Header.Revision</a> 获取到当前的值。</li>
<li><code>CreateRevision</code>仅作用于单个 key，它记录的是这个 key 被创建时的全局时钟（Revision）。一般通过 <a href="https://github.com/etcd-io/etcd/blob/v3.3.10/mvcc/mvccpb/kv.pb.go#L64">KeyValue.CreateRevision</a> 来获取。</li>
<li><code>ModRevision</code>也是单个 key 才有的概念，它表示这个 key 上一次被更改时，全局的版本是多少。也是通过 <a href="https://github.com/etcd-io/etcd/blob/v3.3.10/mvcc/mvccpb/kv.pb.go#L66">KeyValue.ModRevision </a>获取到。</li>
<li><code>Version</code>仅仅是个计数器，与全局的 Revision 无关，代表了当前的 key 从创建到现在被更改了多少次。</li>
</ul>
<p>这里的概念有点像 Linux 文件系统里的各种时间。整个系统的时钟是一直往前走的（Revision），我们在08:01创建了一个文件<code>my.file</code>（CreateRevision），08:07分又更改了它（ModRevision）。系统会记录下这几个时间点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ stat my.file
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">Access: 2019-08-29 08:01:43.345815131 +0800
</span></span><span class="line"><span class="cl">Modify: 2019-08-29 09:07:46.461380645 +0800
</span></span><span class="line"><span class="cl">Change: 2019-08-29 09:07:46.461380645 +0800
</span></span><span class="line"><span class="cl"> Birth: -
</span></span></code></pre></td></tr></table>
</div>
</div><p>有了这个 Revision 之后，我们就像有了时光机一样，可以获取到系统在过去某个时间点的状态。比如<code>GET</code>函数就支持传入一个<code>WithRev(revision)</code>参数，来得到指定的 key 在指定的 revision 时的值。</p>
<h3 id="etcd-中的微事务">etcd 中的微事务</h3>
<p>etcd v3 中引入了一个微事务的概念（mini-transaction），允许用户在一次修改中批量执行多个操作，这意味着这一组操作被绑定成一个原子操作，并共享同一个修订号。它的写法有点类似一个 <a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2">CAS</a> ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">Txn</span><span class="p">().</span><span class="nf">If</span><span class="p">(</span><span class="nx">cond1</span><span class="p">,</span> <span class="nx">cond2</span><span class="p">,</span> <span class="err">…</span><span class="p">).</span><span class="nf">Then</span><span class="p">(</span><span class="nx">op1</span><span class="p">,</span> <span class="nx">op2</span><span class="p">,</span> <span class="err">…</span><span class="p">).</span><span class="nf">Else</span><span class="p">(</span><span class="nx">op1</span><span class="err">’</span><span class="p">,</span> <span class="nx">op2</span><span class="err">’</span><span class="p">,</span> <span class="err">…</span><span class="p">).</span><span class="nf">commit</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果<code>If</code>语句中的条件全部为真，则整个事务的返回值为<code>true</code>，并且<code>Then</code>中的操作会被执行，否则返回<code>false</code>并执行<code>Else</code>中的操作。</p>
<h2 id="使用姿势">使用姿势</h2>
<p>在并发编程领域，我们经常用银行转账的例子来说明原子操作的重要性。为了确保并发安全，要么使用一个悲观锁来避免冲突，要么就用乐观锁来检测冲突并重试。现在在 etcd 的场景下，有了<code>mini-transaction</code>和<code>ModRevision</code>的加持，我们很容易就想到用它们来实现一把乐观锁：</p>
<p><img src="/image/2019/08/etcd-transaction-isolation-levels/cas-transfer-money.svg" alt="cas transfer money"></p>
<p>根据这个思路写出来的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">txnXfer</span><span class="p">(</span><span class="nx">etcd</span> <span class="o">*</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">amount</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">ok</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">doTxnXfer</span><span class="p">(</span><span class="nx">etcd</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">amount</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">err</span> <span class="c1">// 发生了错误，则直接给用户返回错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">nil</span>  <span class="c1">// 转账成功就返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 发生冲突了，需要重试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">doTxnXfer</span><span class="p">(</span><span class="nx">etcd</span> <span class="o">*</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">amount</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 利用 Txn 的原子性同时获取A和B的余额以及ModRevision
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">getResp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">etcd</span><span class="p">.</span><span class="nf">Txn</span><span class="p">(</span><span class="nx">etcd</span><span class="p">.</span><span class="nf">Ctx</span><span class="p">()).</span><span class="nf">Then</span><span class="p">(</span><span class="nf">OpGet</span><span class="p">(</span><span class="nx">from</span><span class="p">),</span> <span class="nf">OpGet</span><span class="p">(</span><span class="nx">to</span><span class="p">)).</span><span class="nf">Commit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 读取在当前时刻A和B的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fromKV</span> <span class="o">:=</span> <span class="nx">getResp</span><span class="p">.</span><span class="nx">Responses</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">GetRangeResponse</span><span class="p">().</span><span class="nx">Kvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="nx">toKV</span> <span class="o">:=</span> <span class="nx">getResp</span><span class="p">.</span><span class="nx">Responses</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">GetRangeResponse</span><span class="p">().</span><span class="nx">Kvs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fromValue</span><span class="p">,</span> <span class="nx">toValue</span> <span class="o">:=</span> <span class="nf">toUInt64</span><span class="p">(</span><span class="nx">fromKV</span><span class="p">.</span><span class="nx">Value</span><span class="p">),</span> <span class="nf">toUint64</span><span class="p">(</span><span class="nx">toKV</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">fromValue</span> <span class="p">&lt;</span> <span class="nx">amount</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="err">“</span><span class="nx">insufficient</span> <span class="nx">value</span><span class="err">”</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 再准备一个事务，其中的比较部分是查看 ModRevision 有没有变化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">txn</span> <span class="o">:=</span> <span class="nx">etcd</span><span class="p">.</span><span class="nf">Txn</span><span class="p">(</span><span class="nx">etcd</span><span class="p">.</span><span class="nf">Ctx</span><span class="p">()).</span><span class="nf">If</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">v3</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="nx">v3</span><span class="p">.</span><span class="nf">ModRevision</span><span class="p">(</span><span class="nx">from</span><span class="p">),</span> <span class="s">&#34;=&#34;</span><span class="p">,</span> <span class="nx">fromKV</span><span class="p">.</span><span class="nx">ModRevision</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="nx">v3</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="nx">v3</span><span class="p">.</span><span class="nf">ModRevision</span><span class="p">(</span><span class="nx">to</span><span class="p">),</span> <span class="s">&#34;=&#34;</span><span class="p">,</span> <span class="nx">toKV</span><span class="p">.</span><span class="nx">ModRevision</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果从上次读取到现在还没有别人更改过，那就写入处理后的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">txn</span> <span class="p">=</span> <span class="nx">txn</span><span class="p">.</span><span class="nf">Then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nf">OpPut</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nf">fromUint64</span><span class="p">(</span><span class="nx">fromValue</span> <span class="o">-</span> <span class="nx">amount</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">        <span class="nf">OpPut</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nf">fromUint64</span><span class="p">(</span><span class="nx">toValue</span> <span class="o">-</span> <span class="nx">amount</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 提交第二个事务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">putResp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">txn</span><span class="p">.</span><span class="nf">Commit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果事务的比较部分为真，putResp.Succeeded就是true，否则为false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">putResp</span><span class="p">.</span><span class="nx">Succeeded</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，这部分代码除了转账的业务逻辑外，大部分都是实现乐观锁的样板代码，包括两次事务操作、冲突检测、冲突发生时的重试等，写起来比较繁琐。幸好 stm.go 把这部分逻辑进行了封装，抽象出了一个公共的事务处理框架，我们只需把业务相关的代码传给 stm，它会做事务管理，并适时调用我们的业务代码。现在来看看用 stm 重构后的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">txnXfer</span><span class="p">(</span><span class="nx">cli</span> <span class="o">*</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">amount</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// NewSTM创建了一个原子事务的上下文，并把我们的业务代码作为一个函数传进去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">NewSTM</span><span class="p">(</span><span class="nx">cli</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">stm</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nx">STM</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// stm.Get封装好了事务的读操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">fromV</span> <span class="o">:=</span> <span class="nf">toUInt64</span><span class="p">(</span><span class="nx">stm</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">from</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nx">toV</span> <span class="o">:=</span> <span class="nf">toUInt64</span><span class="p">(</span><span class="nx">stm</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">to</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">fromV</span> <span class="p">&lt;</span> <span class="nx">amount</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="err">“</span><span class="nx">insufficient</span> <span class="nx">value</span><span class="err">”</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// stm.Put封装好了事务的写操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">stm</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nf">fromUInt64</span><span class="p">(</span><span class="nx">toV</span> <span class="o">+</span> <span class="nx">amount</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nx">stm</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nf">fromUInt64</span><span class="p">(</span><span class="nx">fromV</span> <span class="o">-</span> <span class="nx">amount</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>眼花缭乱的<code>ModRevision</code>不见了，事务处理也不见了，整段代码变得清晰明了了很多。所以 stm 的使用特别简单——我们只需把业务相关的代码封装成可重入的函数传给 stm，然后 stm 会处理好其余所有的细节，cool~</p>
<h2 id="内部实现">内部实现</h2>
<p>先来看看传给业务程序的<code>concurrency.STM</code>长什么样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// STM is an interface for software transactional memory.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">STM</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Get returns the value for a key and inserts the key in the txn&#39;s read set.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Put adds a value for a key to the write set.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Put</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">v3</span><span class="p">.</span><span class="nx">OpOption</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Rev returns the revision of a key in the read set.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Rev</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Del deletes a key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Del</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// commit attempts to apply the txn&#39;s changes to the server.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">commit</span><span class="p">()</span> <span class="o">*</span><span class="nx">v3</span><span class="p">.</span><span class="nx">TxnResponse</span>
</span></span><span class="line"><span class="cl">    <span class="nf">reset</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>原来它是一个接口，提供了对某个 key 的 <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CURD</a> 操作。而实现了 STM 接口的总共有两个类：<a href="https://github.com/etcd-io/etcd/blob/v3.3.10/clientv3/concurrency/stm.go#L170">stm</a> 和 <a href="https://github.com/etcd-io/etcd/blob/v3.3.10/clientv3/concurrency/stm.go#L300">stmSerializable</a>。具体选择哪个实现，则是由我们指定的隔离级别决定的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">mkSTM</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">*</span><span class="nx">stmOptions</span><span class="p">)</span> <span class="nx">STM</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">iso</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">SerializableSnapshot</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">stmSerializable</span><span class="p">{</span><span class="o">...</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">s</span><span class="p">.</span><span class="nx">conflicts</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">[]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Cmp</span> <span class="p">{</span><span class="k">return</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">rset</span><span class="p">.</span><span class="nf">cmps</span><span class="p">(),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">wset</span><span class="p">.</span><span class="nf">cmps</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">rset</span><span class="p">.</span><span class="nf">first</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">...</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">Serializable</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">stmSerializable</span><span class="p">{</span><span class="o">...</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">s</span><span class="p">.</span><span class="nx">conflicts</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">[]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Cmp</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">rset</span><span class="p">.</span><span class="nf">cmps</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">RepeatableReads</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">stm</span><span class="p">{</span><span class="o">...</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">s</span><span class="p">.</span><span class="nx">conflicts</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">[]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Cmp</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">rset</span><span class="p">.</span><span class="nf">cmps</span><span class="p">()</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">ReadCommitted</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">stm</span><span class="p">{</span><span class="o">...</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">s</span><span class="p">.</span><span class="nx">conflicts</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">[]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Cmp</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到目前共支持了4种隔离级别，并且不同的隔离级别除了使用不同的 STM 实现外，他们的<code>conflicts</code>函数也不一样，这个我们待会再讲。先挑一个典型的<code>RepeatableReads</code>来看看它的实现：</p>
<h3 id="repeatablereads">RepeatableReads</h3>
<p>内部的状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// stm implements repeatable-read software transactional memory over etcd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">stm</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// rset holds read key values and revisions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">rset</span> <span class="nx">readSet</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// wset holds overwritten keys and their values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">wset</span> <span class="nx">writeSet</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// getOpts are the opts used for gets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">getOpts</span> <span class="p">[]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">OpOption</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// conflicts computes the current conflicts on the txn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">conflicts</span> <span class="kd">func</span><span class="p">()</span> <span class="p">[]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Cmp</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的两个字段<code>readSet</code>和<code>writeSet</code>，底层类型是一个<code>map</code>，用来缓存在当前事务中进行过的读写操作。<code>conflicts</code>是在上面的工厂函数<code>mkSTM</code>中赋值的，用来在事务提交的时候做冲突检测。</p>
<h4 id="读写">读写</h4>
<p>事务中的读写调用的是<code>stm.Get</code>和<code>stm.Put</code>函数。简化后的逻辑大概是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stm</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 先看看之前有没有写过这个值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">wv</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">wset</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="nx">wv</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 再看看有没有读过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">rv</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">rset</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">rv</span><span class="p">.</span><span class="nx">Kvs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果都没有，则向etcd发起一次查询请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">rk</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">getOpts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 查询后再缓存进read set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">s</span><span class="p">.</span><span class="nx">rset</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">rk</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">rk</span><span class="p">.</span><span class="nx">Kvs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 写操作都是先写进本地缓存里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stm</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="nx">s</span><span class="p">.</span><span class="nx">wset</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">val</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于读请求，先以本地最新的更新为准，如果之前从没处理过这个 key ，则到 etcd 中查询，并缓存下来，这样就可以做到<em>可重复读</em> （RepeatableReads）。对于写操作，都是先写进本地缓存，直到事务提交时才真正写到 etcd 里。</p>
<h4 id="提交">提交</h4>
<p>当我们的业务代码调用结束后，stm 就来尝试提交事务了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stm</span><span class="p">)</span> <span class="nf">commit</span><span class="p">()</span> <span class="o">*</span><span class="nx">v3</span><span class="p">.</span><span class="nx">TxnResponse</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">txnresp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">Txn</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ctx</span><span class="p">).</span><span class="nf">If</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">s</span><span class="p">.</span><span class="nf">conflicts</span><span class="p">()</span><span class="o">...</span><span class="p">).</span><span class="nf">Then</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">wset</span><span class="p">.</span><span class="nf">puts</span><span class="p">()</span><span class="o">...</span><span class="p">).</span><span class="nf">Commit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>提交事务就是利用 etcd 的<code>Txn</code>，把<code>writeSet</code>中的数据写出去，这里要注意的是<code>If</code>中的冲突检测，就是我们在构建的时候指定的<code>conflicts</code>函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nx">conflicts</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">[]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Cmp</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">rset</span><span class="p">.</span><span class="nf">cmps</span><span class="p">()</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>看来<code>conflicts</code>函数中真正干活的是<code>readSet.cmps()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// cmps guards the txn from updates to read set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rs</span> <span class="nx">readSet</span><span class="p">)</span> <span class="nf">cmps</span><span class="p">()</span> <span class="p">[]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Cmp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cmps</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Cmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rs</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">rk</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rs</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">cmps</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cmps</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                 <span class="nx">v3</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="nx">v3</span><span class="p">.</span><span class="nf">ModRevision</span><span class="p">(</span><span class="nx">k</span><span class="p">),</span> <span class="s">&#34;=&#34;</span><span class="p">,</span> <span class="nx">rk</span><span class="p">.</span><span class="nx">Kvs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">ModRevision</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">cmps</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它的逻辑就是构造一堆比较操作符，确保<code>readSet</code>中的数据，在读取进缓存之后再也没有被更改过，即 ModRevision 没有变。</p>
<p>所以梳理一下，<code>RepeatableReads</code>实现的两个关键点：</p>
<ul>
<li>用<code>readSet</code>缓存已经读过的数据，这样下次再读取同样数据的时候才能得到同样的结果，这确保了可重复读。</li>
<li>用<code>readSet</code>数据的<code>ModRevision</code>做冲突检测，确保本事务读到的数据都是最新的。</li>
</ul>
<h3 id="readcommitted">ReadCommitted</h3>
<p><code>ReadCommitted</code>跟<code>RepeatableReads</code>的实现类似，唯一不同的是它的冲突检测函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nx">conflicts</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">[]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Cmp</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，其实<code>ReadCommitted</code>啥冲突也不检测，它只是确保自己读到的是别人已经提交的数据，其他什么保障也没有啊？！</p>
<h3 id="serializable">Serializable</h3>
<p><code>Serializable</code>使用的是<code>stmSerializable</code>类，它与上面两个使用的<code>stm</code>一个主要不同点在于，它第一次读完了会把当时的版本号给记录下来，下次再向 etcd 发出读请求的时候会带上这个版本号，表示我就要当时那个版本的数据，这确保了该事务所有的读操作读到的都是<strong>同一时刻</strong>的内容。这就相当于在事务开始时，对 etcd 做了一个快照，这样它读取到的数据就不会受到其他事务的影响，从而达到事务串行化（Serializable）执行的效果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stmSerializable</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">keys</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">firstRead</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">rset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1">// 是不是第一次读操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">resp</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">stm</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="nx">keys</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">firstRead</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 记录下first read的版本号，作为后续Get操作的Option参数传进去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">s</span><span class="p">.</span><span class="nx">getOpts</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">OpOption</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">v3</span><span class="p">.</span><span class="nf">WithRev</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nx">Revision</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="nx">v3</span><span class="p">.</span><span class="nf">WithSerializable</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">respToValue</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，在第一个读操作完成后，我们就设置了两个<code>OpOption</code>给后续的读操作使用。第一个 Option 指定了要读的版本号，第二个 Option 是告诉 etcd server 直接把它当前所知道的结果返回，而不需要通过 raft 协议跟别人确认一下它目前的结果是不是最新的，这提升了读取时的性能同时也能满足该场景下的需求（默认不加这个参数时是线性 linearizable 一致性的读取策略，可靠但是慢）。</p>
<h3 id="serializablesnapshot">SerializableSnapshot</h3>
<p><code>SerializableSnapshot</code>和<code>Serializable</code>也是类似，不同的是它的隔离级别更严格些：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nx">conflicts</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">[]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Cmp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">rset</span><span class="p">.</span><span class="nf">cmps</span><span class="p">(),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">wset</span><span class="p">.</span><span class="nf">cmps</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">rset</span><span class="p">.</span><span class="nf">first</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// cmps returns a cmp list testing no writes have happened past rev
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ws</span> <span class="nx">writeSet</span><span class="p">)</span> <span class="nf">cmps</span><span class="p">(</span><span class="nx">rev</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">[]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Cmp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cmps</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Cmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ws</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ws</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">cmps</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cmps</span><span class="p">,</span> <span class="nx">v3</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="nx">v3</span><span class="p">.</span><span class="nf">ModRevision</span><span class="p">(</span><span class="nx">key</span><span class="p">),</span> <span class="s">&#34;&lt;&#34;</span><span class="p">,</span> <span class="nx">rev</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">cmps</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>即，它不仅要确保我读取过的数据是最新的，也要确保我要写入的数据也没有被别人更改过，这是最高的隔离级别，也是 stm 的默认隔离级别。在传统数据库中，要实现这样一个隔离级别，一般通过读写锁来限制竞态冲突，而这里则是通过极其严格的冲突检测，稍微有点不一样的地方它就认为发生冲突了，需要 stm 去重试。</p>
<h3 id="区别汇总">区别汇总</h3>
<p>综上所述，这四种隔离级别在实现上主要有两点区别：<strong>读取数据的版本</strong>和<strong>冲突检测的方法</strong>。如果我们将事务刚开始时的版本号称为<code>FIRST_REV</code>，将读操作真正发生时候的版本号称为<code>CURRENT_REV</code>，将 key 的 ModRevision 简称为<code>MOD_REV</code>，那它们的区别可以用一张表总结出来：</p>
<table>
<thead>
<tr>
<th>Isolation Level</th>
<th>Read Revision</th>
<th>Conflict Detection</th>
</tr>
</thead>
<tbody>
<tr>
<td>RepeatableReads</td>
<td>CURRENT_REV</td>
<td>readSet: MOD_REV == CURRENT_REV</td>
</tr>
<tr>
<td>ReadCommitted</td>
<td>CURRENT_REV</td>
<td>nil</td>
</tr>
<tr>
<td>Serializable</td>
<td>FIRST_REV</td>
<td>readSet: MOD_REV == FIRST_REV</td>
</tr>
<tr>
<td>SerializableSnapshot</td>
<td>FIRST_REV</td>
<td>readSet: MOD_REV == FIRST_REV<br />writeSet: MOD_REV &lt; FIRST_REV</td>
</tr>
</tbody>
</table>
<p>而对于 STM 接口的两个实现<code>stm</code>和<code>stmSerializable</code>，它们的区别在于，读取操作是否会受到其他事务的影响。如下图所示：</p>
<p><img src="/image/2019/08/etcd-transaction-isolation-levels/serializable-read.svg" alt="serializable read"></p>
<h2 id="总结">总结</h2>
<p>本文以 etcd 为例，介绍了事务隔离机制的实现。当然，这里的实现跟传统关系型数据库（MySQL、PostgreSQL）的实现还是有一定区别的。关系型数据库一般通过给一个 row 增加两个字段（transaction-created, transaction-deleted）来做数据可见性的隔离，再辅以悲观锁来做并发控制，而 etcd 里的实现类似于事务型内存，在一个事务的上下文里先缓存业务代码的所有读、写请求，在真正提交的时候根据不同的隔离级别做冲突检测，从而决定是否重试。可以看到，底层暴露出来的 MVCC 原语具有极强的表达能力，我们在客户端就可以做到原本在服务端才能做到的事情。</p>
<p>另外，就 etcd 常见的使用场景官方的 SDK 中都有现成的实现（参见 <a href="https://github.com/etcd-io/etcd/tree/v3.3.10/clientv3/concurrency">concurrency</a>, <a href="https://github.com/etcd-io/etcd/tree/v3.3.10/contrib/recipes">contrib/recipes</a>），希望大家不要再重复造轮子了，官方的轮子又大又圆，而自己造的轮子往往都是 ctrl+c、ctrl+v 来的代码，到处是坑。多读读源代码，能让你少趟很多坑。</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://github.com/etcd-io/etcd/tree/v3.3.10">etcd v3.3.10</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p><a href="https://github.com/etcd-io/etcd/issues/6518">What is different between Revision, ModRevision and Version?</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"><a href="https://blog.betacat.io">喵叔</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2020-01-03
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a>（转载请注明出处）</span>
  </p>
</div>


    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/2020/03/a-pattern-for-writing-testable-go-code/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">编写可测试 Go 代码的一种模式</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/develop-and-debug-k8s-microservices-locally-using-telepresence/">
            <span class="next-text nav-default">使用 Telepresence 在本地调试 Kubernetes 微服务</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "polyrabbit/polyrabbit.github.io"
            issue-term="title"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="/email.gif" rel="me noopener" class="iconfont"
      title="email"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="javascript:alert%28%27My%20tweets%20are%20protected%20now%27%29" rel="me noopener" class="iconfont"
      title="twitter"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1264 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M1229.8616 18.043658c0 0-117.852626 63.135335-164.151872 67.344358-105.225559-164.151872-505.082682-92.598492-437.738325 223.078185C278.622548 312.675223 89.216542 47.506814 89.216542 47.506814s-117.852626 189.406006 75.762402 345.139833C127.097743 396.85567 55.544363 371.601535 55.544363 371.601535S26.081207 535.753407 253.368414 615.724832c-21.045112 29.463156-113.643603 8.418045-113.643603 8.418045s25.254134 143.10676 231.496229 180.987961c-143.10676 130.479693-387.230056 92.598492-370.393967 105.225559 206.242095 189.406006 1119.599946 231.496229 1128.01799-643.98042C1179.353331 249.539887 1263.533778 123.269217 1263.533778 123.269217s-130.479693 37.881201-138.897738 33.672179C1225.652577 98.015083 1229.8616 18.043658 1229.8616 18.043658"></path>
</svg>

    </a>
  
    <a href="https://www.linkedin.com/in/%E6%98%8C%E6%96%B0-%E7%BC%AA-b46b8591/" rel="me noopener" class="iconfont"
      title="linkedin"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="33" height="33">
  <path d="M872.405333 872.618667h-151.637333v-237.610667c0-56.661333-1.152-129.578667-79.018667-129.578667-79.061333 0-91.136 61.653333-91.136 125.397334v241.792H398.976V384h145.664v66.602667h1.962667c20.352-38.4 69.845333-78.933333 143.786666-78.933334 153.642667 0 182.058667 101.12 182.058667 232.746667v268.202667zM227.712 317.141333a87.978667 87.978667 0 0 1-88.021333-88.106666 88.064 88.064 0 1 1 88.021333 88.106666z m76.032 555.477334H151.68V384h152.064v488.618667zM948.266667 0H75.562667C33.792 0 0 33.024 0 73.770667v876.458666C0 991.018667 33.792 1024 75.562667 1024h872.576C989.866667 1024 1024 991.018667 1024 950.229333V73.770667C1024 33.024 989.866667 0 948.138667 0h0.128z"></path>
</svg>

    </a>
  
    <a href="https://github.com/polyrabbit" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://blog.betacat.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2018 -
    2023
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        <a href="https://blog.betacat.io">喵叔</a>
        
      </span></span>

  
  

  
    <span>
      <a class="beian" href="http://www.beian.miit.gov.cn/" target="_blank">沪ICP备17033881号-1</a>
    </span>
  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
